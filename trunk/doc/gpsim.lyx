#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass book
\language english
\inputencoding default
\fontscheme times
\graphics default
\paperfontsize 10
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\leftmargin -0.5cm
\topmargin 0.5cm
\rightmargin 0.5cm
\bottommargin 0.5cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation skip
\defskip smallskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

gpsim
\layout Author

T.
 Scott Dattalo
\layout Date

11 OCTOBER 2005
\layout Standard


\begin_inset LatexCommand \tableofcontents{}

\end_inset 


\layout Chapter*

Introduction
\layout Standard

gpsim is a full-featured software simulator for Microchip PIC microcontrollers
 distributed under the GNU General Public License 
\begin_inset Note
collapsed true

\layout Standard

scott2 Wed Sep 30 13:25:58 1998
\end_inset 

(see the COPYING section).
\layout Standard

gpsim has been designed to be as accurate as possible.
 Accuracy includes the entire PIC - from the core to the I/O pins and including
 ALL of the internal peripherals.
 Thus it's possible to create stimuli and tie them to the I/O pins and test
 the PIC the same PIC the same way you would in the real world.
\layout Standard

gpsim has been designed to be as fast as possible.
 Real time simulation speeds of 20Mhz pics are possible.
\layout Standard

gpsim can be controlled from either a graphical user interface (GUI), a
 command line interface (CLI) or by a remote process.
 Typical debugging features like breakpoints, single stepping, disassembling,
 memory inspect & change, and so on are all supported.
 In addition, complex debugging features like real time tracing, assertions,
 conditional breaks, and plugin modules to name a few are also supported.
\layout Chapter

gpsim - An Overview
\layout Standard

If you don't care to wade through details, this chapter should help you
 get things up and running.
 The INSTALL and README files will provide more up-to-date information then
 this document, so please refer to those first.
\layout Section

Making the executable
\layout Standard

gpsim's executable is create in a manner that's consistant with many of
 the other open source software:
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="left" valignment="top" leftline="true" width="0pt">
<column alignment="left" valignment="top" leftline="true" rightline="true" width="0pt">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

command 
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

description
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

tar -xvzf gpsim-x.y.z.tar.gz
\end_inset 
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

expand the compressed tar file
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

./configure
\end_inset 
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Create a 'makefile' unique to your system
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

make
\end_inset 
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

compile gpsim
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

make install
\end_inset 
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

install gpsim
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard

The last step will require root privileges.
\layout Subsection

Make Details - ./configure options
\layout Subsubsection*

gui-less
\layout Standard

The default configuration will provide a gui (graphical user interface).
 The cli (command line interface) is still available, however many people
 prefer just to use the cli.
 These hardy souls may build a command-line only interface by configuring
 gpsim:
\layout LyX-Code

./configure --disable-gui
\layout Subsubsection*

debugging
\layout Standard

If you want to debug gpsim then you'll probably use gdb.
 Consequently, you'll want to disable shared libraries:
\layout LyX-Code

./configure --disable-shared
\layout Standard

This will create one, huge monolithic executable with symbolic information.
 
\layout Subsection

RPMs
\layout Standard

gpsim is also distributed in RPM form.
 In recent versions, there are two RPMs: gpsim-devel and gpsim.
 Both of these must be installed.
 There is also a RPM for the source code.
 This can be used to build a binary RPM unique to your system.
 Please see the latest INSTALL and README for the most up to date information.
\layout Subsection

Windows
\layout Standard

gpsim runs on Windows too.
 Borut Razem maintains the gpsim Windows web site:
\layout Quote

http://gpsim.sourceforge.net/gpsimWin32/gpsimWin32.html
\layout Standard

You can find detailed instructions there for installing gpsim and its dependenci
es.
 Snap shots can be found:
\layout Quote

http://gpsim.sourceforge.net/snap.php
\layout Section

Running
\layout Standard

The executable created above is called: gpsim.
 The following command line options may be specified when gpsim is invoked.
\layout LyX-Code

gpsim [-?] [-p <device> [<hex_file>]] [-c <stc_file>]
\layout LyX-Code

  -p, --processor=<processor name>     processor (e.g.
 -pp16c84 for the 'c84)
\layout LyX-Code

  -c, --command=STRING                 startup command file
\layout LyX-Code

  -s                                   .cod symbol file
\layout LyX-Code

  -L, --                               colon separated list of directories
 to
\layout LyX-Code

                                       search.
\layout LyX-Code

  -v, --version                        gpsim version
\layout LyX-Code

  -i, --cli                            command line mode only
\layout LyX-Code

  -d, --icd=STRING                     use ICD (e.g.
 -d /dev/ttyS0).
\layout LyX-Code

  Help options:
\layout LyX-Code

  -?, --help                           Show this help message
\layout LyX-Code

  --usage                              Display brief usage message
\layout Standard

Typically gpsim will be invoked like:
\layout LyX-Code

[My-Computer]$ gpsim -s mypic-program.cod
\layout Standard

(The 
\emph on 
[My-Computer]$
\emph default 
 text is an example of a typical bash command prompt - you'll only type
 the text after this prompt).
 This loads the .cod file generated by gputils.
\layout Standard

Under Windows, gpsim can also be invoked by navigating through the Start/Progam
 menu.
 This will open a DOS window to provide access to the command line interface.
 It's also possible to open a DOS window (or CygWin bash session) and invoke
 gpsim from there.
\layout Section

Requirements
\layout Standard

gpsim has been developed under Linux.
 It should build and run just fine under the popular Linux distributions
 like Redhat.
 gpsim has also been ported to the MAC, MicroSoft Windows, Solaris, and
 BSD.
 Two packages gpsim requires that may not be available with all Linux distributi
ons are readline and gtk (the gimp tool kit).
 The ./configure script should tell you if these packages are not installed
 on your system or if the revisions that are installed are too old.
 
\layout Standard

There are no minimum hardware requirements to run gpsim.
 Faster is better though!
\layout Standard

gputils, the gnupic utilities package, is also very useful.
 gpsim will accept straight hex files, but if you want to do any symbolic
 debugging then you'll want to use the .cod
\begin_inset Foot
collapsed true

\layout Standard

.cod files are symbol files that were created by ByteCraft and are used by
 Microchip.
\end_inset 

 files that gputils produces.
 The .cod files are in the same format as the .cod files MPASM
\begin_inset Foot
collapsed true

\layout Standard

MPASM is Microchip's Assembler.
\end_inset 

 produces.
 
\layout Chapter

Command Line Interface
\layout Standard

The command line interface is fairly straight-forward.
 The table below summarizes the available commands.
 Brief descriptions of these commands can also be displayed by typing 
\emph on 
help
\emph default 
 at the command line.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center 

\begin_inset  Tabular
<lyxtabular version="3" rows="27" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" width="0pt">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0pt">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

command
\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

summary
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

attach
\begin_inset LatexCommand \index{attach}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Attach stimuli to nodes 
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

break
\begin_inset LatexCommand \index{break}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Set a break point
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

bus
\begin_inset LatexCommand \index{bus}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Add or display node busses
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

clear
\begin_inset LatexCommand \index{clear}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Remove a break point
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

disassemble
\begin_inset LatexCommand \index{disassemble}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Disassemble the current cpu
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

dump
\begin_inset LatexCommand \index{dump}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Display either the RAM or EEPROM 
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

frequency
\begin_inset LatexCommand \index{frequency}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Set processor frequency
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

help
\begin_inset LatexCommand \index{help}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Type help "command" for more help on a command
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

icd
\begin_inset LatexCommand \index{icd}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

In Circuit Debugger support.
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

list
\begin_inset LatexCommand \index{list}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Display source and list files
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

load
\begin_inset LatexCommand \index{load}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Load either a hex or command file
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

log
\begin_inset LatexCommand \index{log}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Log/record events to a file
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

node
\begin_inset LatexCommand \index{node}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Add or display stimulus nodes
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

module
\begin_inset LatexCommand \index{module}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family roman 
\series medium 
\shape up 
\size normal 
\emph off 
\bar no 
\noun off 
\color none
Select & Display modules
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

processor
\begin_inset LatexCommand \index{processor}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Add/list processors
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

quit
\begin_inset LatexCommand \index{quit}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Quit gpsim
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

reset
\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family roman 
\series medium 
\shape up 
\size normal 
\emph off 
\bar no 
\noun off 
\color none
Reset all or parts of the simulation
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

run
\begin_inset LatexCommand \index{run}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Execute the pic program
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

set
\begin_inset LatexCommand \index{set}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family roman 
\series medium 
\shape up 
\size normal 
\emph off 
\bar no 
\noun off 
\color none
display and control gpsim behavior flags
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

step
\begin_inset LatexCommand \index{step}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Execute one or more instructions
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

stimulus
\begin_inset LatexCommand \index{stimulus}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Create a stimulus
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

stopwatch
\begin_inset LatexCommand \index{stopwatch}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\family roman 
\series medium 
\shape up 
\size normal 
\emph off 
\bar no 
\noun off 
\color none
Measure time between events
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

symbol
\begin_inset LatexCommand \index{symbol}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Add/list symbols
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

trace
\begin_inset LatexCommand \index{trace}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Dump the trace history
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

version
\begin_inset LatexCommand \index{version}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Display gpsim's version
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

x
\begin_inset LatexCommand \index{x}

\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

examine and/or modify memory
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard

The built in 'help' command provides additional online information.
\layout Section

attach
\begin_inset LatexCommand \index{attach}

\end_inset 


\layout LyX-Code

attach node1 stimulus1 [stimulus2 stimulus_N]
\layout Standard

attach is used to define the connections between stimuli and nodes.
 At least one node and one stimulus must be specified.
 If more stimuli are specified then they will all be attached to the node
 examples:
\layout LyX-Code

gpsim> node  n1                # Define a new node.
\layout LyX-Code

gpsim> attach n1 porta4 portb0 # Connect two I/O pins to the node.
\layout LyX-Code

gpsim> node                    # Display the new "net list".
\layout Section

break
\begin_inset LatexCommand \index{break}

\end_inset 


\layout Standard

The break command is used to set and examine break points.
 New break points are assigned a unique number.
 This number can be used to query or clear the break point.
 Break points halt the simulation when the condition associated with them
 is true.
 Break points are ignored during single stepping.
 See chapter 
\begin_inset LatexCommand \ref{cha:Assertions-and-Extended}

\end_inset 

 for more examples of breakpoints.
\layout Subsubsection*

Examining break points
\layout LyX-Code

break [bp_number]
\layout Standard

Break points can be examined by typing the break command without any options.
 Specific breaks can be queried by specifying the break point number.
 
\layout Subsubsection*

Program Memory/Execution breaks
\layout Standard

The most common break point is an execution break point.
 This one halts execution whenever the program counter reaches the address
 at which the break point is set.
 The syntax is:
\layout LyX-Code

break e|r|w ADDRESS [expr]
\layout Standard

The simulation halts when the address is executed, read, or written.
 The ADDRESS can be a symbol or a number.
 If the optional expression is specified, then it must evaluate to true
 before the simulation will halt.
 The read and write options only apply to those processors that can manipulate
 their own program memory.
\layout Subsubsection*

Register Memory breaks
\layout Standard

gpsim can also associate break points with register accesses.
 This is useful for capturing bugs that stomp on RAM.
 E.g.
 you can say something like 
\begin_inset Quotes eld
\end_inset 

halt execution whenever bit 4 of register 42 is cleared
\begin_inset Quotes erd
\end_inset 

.
 The command line syntax is:
\layout LyX-Code

break r|w REGISTER [expr] 
\layout Standard

The simulation halts when 
\emph on 
REGISTER
\emph default 
 is read or written and the optional expression evaluates to true.
 There are two styles of expressions supported.
 One involves only expressions of the 
\emph on 
REGISTER
\emph default 
, the other is completely arbitrary.
 The examples below illustrate the differences.
\layout Standard

Here's an example of a register write break.
 This one will halt the simulation if any value is written to the variable
 named 
\emph on 
temp1
\emph default 
.
 
\layout LyX-Code

break w temp1
\layout Standard

Here the write is conditioned to happen for only a certain value:
\layout LyX-Code

break w temp1==0x22
\layout Standard

Here the condition applies to specific bits:
\layout LyX-Code

break w temp1 & 0b11110000 == 0b11000000
\layout Standard

This one breaks only if the hex digit 'C' is written to the upper nibble
 of temp1.
\layout Subsubsection*

Boolean Expressions
\layout Standard

Sometimes it's necessary to specify an auxillary condition with a break
 point.
 For example, there may be a temporary variable that is shared throughout
 the code.
 You may wish to trap writes to that variable only while executing a specific
 subroutine.
 For example, the following break point triggers when temp1 is written and
 while the program counter is in between the labels 
\emph on 
func_start
\emph default 
 and 
\emph on 
func_end
\emph default 
:
\layout LyX-Code

break w temp1 (pc >= func_start && pc < func_end)
\layout Standard


\emph on 
TIP:
\emph default 
 Use this type of break point if you suspect an interrupt routine is over
 writing a variable.
\layout Standard

Another situation is one where you wish to trap writes to a variable only
 if some other variable is a certain value:
\layout LyX-Code

break w temp1 (CurTask & 0x0f != 0b101)
\layout Standard

If the firmware writes to the variable temp1 then the simulation will halt
 if the lower nibble of CurTask is not equal to 5.
\layout Subsubsection*

Attribute Breakpoints
\layout Standard

gpsim also supports a concept of 
\emph on 
attribute breakpoints.
 
\emph default 
Attributes are parameters that gpsim and its modules expose to the user
 interface.
 For example, the simulator stopwatch exposes attributes which support breakpoin
ts.
 This feature is intend mainly for module writers to provide a mechanism
 for allowing the user to control the module.
\layout Subsubsection*

Cycle counter Breakpoints
\layout LyX-Code

break c 
\emph on 
cycle_number
\layout Standard

The cycle counter is gpsim's time keeper.
 It increments once every instruction cycle.
 The 'c' option to the break command allows a break point to be set at a
 particular value of the cycle counter.
\layout Section

clear
\begin_inset LatexCommand \index{clear}

\end_inset 


\layout LyX-Code

clear bp_number
\layout LyX-Code

\layout Standard

The clear command is used to clear break points.
 The break point number must be specified.
 The 
\emph on 
break
\emph default 
 command without any arguments displays all of the currently defined break
 points.
 This can be used to ascertain the break point number.
 Once cleared, a break point is deleted.
 
\begin_inset Foot
collapsed true

\layout Standard

A break point disable/enable feature has been discussed and may be added
 a future date.
\end_inset 


\layout Section

disassemble
\begin_inset LatexCommand \index{disassemble}

\end_inset 


\layout LyX-Code

disassemble [[begin:end] | [length]]
\layout LyX-Code

\layout LyX-Code

\layout Standard

The disassemble command decodes the program memory opcodes into their standard
 mnemonics.
 With no options, the 
\emph on 
disassemble
\emph default 
 command disassembles instructions surrounding the current program counter:
\layout LyX-Code

gpsim> disassemble
\layout LyX-Code

current pc = 0x1c
\layout LyX-Code

    0012 2a03 incf reg3,f,0
\layout LyX-Code

    0014 0004 clrwdt
\layout LyX-Code

    0016 5000 movf reg,w,0
\layout LyX-Code

    0018 1001 iorwf reg1,w,0
\layout LyX-Code

    001a 1002 iorwf reg2,w,0
\layout LyX-Code

==> 001c 1003 iorwf reg3,w,0
\layout LyX-Code

    001e e1f4 bnz $-0x16 ;(0x8)
\layout LyX-Code

    0020 d7ff bra $-0x0 ;(0x00020) 
\layout Standard

With a single numeric option, the disassemble command will 
\layout Section

dump
\begin_inset LatexCommand \index{dump}

\end_inset 


\layout LyX-Code

dump [r | e]
\layout LyX-Code

 
\layout LyX-Code

  dump r or dump with no options will display all of the file
\layout LyX-Code

  registers and special function registers.
\layout LyX-Code

  dump e will display the contents of the eeprom (if the pic
\layout LyX-Code

  being simulated contains any)
\layout Standard

See the 'x' command for examining and modifying individual registers.
\layout Section

echo
\begin_inset LatexCommand \index{echo}

\end_inset 


\layout Standard

The echo command is used like a print statement within configuration files.
 It just lets you display information about your configuration file.
\layout Section

frequency
\begin_inset LatexCommand \index{frequency}

\end_inset 


\layout Standard

This command sets the clock frequency.
 By default gpsim uses 4 MHz as clock.
 The clock frequency is used to compute time in seconds.
 Use this command to adjust this value.
 If no value is provided this command prints the current clock.
 Note that PICs have an instruction clock that's a forth of the external
 clock.
 This value is the external clock.
\layout Section

help
\begin_inset LatexCommand \index{help}

\end_inset 


\layout Standard

By itself, help will display all of the commands along with a brief description
 on how they work.
 'help <command>' provides more extensive online help.
 The help command can also display information about attributes.
\layout Section

icd
\begin_inset LatexCommand \index{icd}

\end_inset 


\layout Standard


\emph on 
icd [open <port>]
\layout Standard

The open command is used to enable ICD mode and specify the serial port
 where the ICD is.
 (e.g.
 "icd open /dev/ttyS0").
 Without options (and after the icd is enabled), it will print some information
 about the ICD.
\layout Section

list 
\begin_inset LatexCommand \index{list}

\end_inset 


\layout LyX-Code

list [[s | l] [*pc] [line_number1 [,line_number2]]]
\layout LyX-Code

Display the contents of source and list files.
 
\layout LyX-Code

Without any options, list will use the last specified options.
 
\layout LyX-Code

list s will display lines in the source (or .asm) file.
 
\layout LyX-Code

list l will display lines in the .lst file 
\layout LyX-Code

list *pc will display either .asm or .lst lines around the pc
\layout Standard

The list command allows you to view the source code while you are debugging.
 
\layout Section

load
\begin_inset LatexCommand \index{load}

\end_inset 


\layout Standard

The load command is used to load either hex, configuration, or .cod files.
 A hex file is usually used to program the physical part.
 Consequently, it provides no symbolic information.
 .cod files on the other hand, do provide symbolic information.
 The only reason to use a hex file is when there's no .cod file available.
\layout Standard

The syntax for loading source code files is:
\layout LyX-Code

load [processortype] file
\layout Standard

gpsim will automatically determine if the file is a .hex or .cod file.
 The optional processortype allows one to override the processor specified
 in a .cod file.
\layout Standard

Configuration files are script files containing gpsim commands.
 These are extremely useful for creating a debugging enviroment that will
 be used repeatedly.
\layout Section

macros
\begin_inset LatexCommand \index{macros}

\end_inset 


\layout Standard

Macros are defined like:
\layout LyX-Code


\emph on 
name
\emph default 
 macro [arg1, arg2, ..., argN]
\layout LyX-Code

   macro body
\layout LyX-Code

endm
\layout Standard

And they're invoked by:
\layout LyX-Code


\emph on 
name
\emph default 
 param1, param2, ..., paramN
\layout Standard

Macros are a way of collecting several parameterized commands into one short
 command.
 The first line of a macro definition specifies the macro's name and optional
 arguments.
 The 
\emph on 
name
\emph default 
 is used to invoke the macro.
 The arguments are text string place holders.
 When a macro is invoked, the parameters are aligned with the arguments.
 I.e.
 
\emph on 
param1
\emph default 
 in the invocation can be thought of being assigned to 
\emph on 
arg1
\emph default 
 in the definition.
 The parameters replace the arguments in the macro body.
\layout Standard

In the following example, a variable or attribute called 
\emph on 
mac_flags
\emph default 
 is being manipulated in an expression.
 The arguments 
\emph on 
add
\emph default 
 and 
\emph on 
mask
\emph default 
 appear in the macro body and provide a parameterized way of manipulating
 this expression.
\layout LyX-Code

mac_exp macro add, mask
\layout LyX-Code

  mac_flags = (mac_flags+add) & mask
\layout LyX-Code

endm 
\layout Standard

Note that the indentation is arbitrary.
 The macro is invoked by:
\layout LyX-Code

mac_exp 1, 0b00001111 # increment the lower nibble
\layout Standard

The parameter 
\emph on 
add
\emph default 
 is replaced by the number 
\emph on 
1
\emph default 
 while 
\emph on 
mask
\emph default 
 is replaced with the binary number 
\emph on 
0b00001111.

\emph default 
 The invocation turns into the gpsim command:
\layout LyX-Code

mac_flags = (mac_flags+1) & 0b00001111
\layout Subsubsection*

Nested Macros
\layout Standard

The macro body can contain any gpsim command.
 Of particular interest are macro invocations within other macros.
 Here's another macro that invokes the one defined above.
\layout LyX-Code

# Nested macro example
\layout LyX-Code

mac1 macro p1, p2
\layout LyX-Code

  run
\layout LyX-Code

  mac_exp p1, p2
\layout LyX-Code

endm 
\layout Standard

And it could be used like:
\layout LyX-Code

mac1  1,      0b00001111   #  test lower nibble
\layout LyX-Code

mac1  (1<<4), 0b11110000   #  test upper nibble
\layout Standard

The first invocation starts the simulator by executing a 
\emph on 
run
\emph default 
 command.
 When a break point is encountered, control returns to the command line
 and the 
\emph on 
mac_exp
\emph default 
 macro is invoked.
\layout Subsubsection*

Displaying Defined Macros
\layout Standard

All currently defined macros can be displayed by typing the macro command
 without a name or arguments:
\layout LyX-Code

gpsim> macro
\layout LyX-Code

mac1 macro p1 p2
\layout LyX-Code

   run
\layout LyX-Code

   mac_exp p1, p2
\layout LyX-Code

endm
\layout LyX-Code

mac_exp macro add mask
\layout LyX-Code

    mac_flags = (mac_flags+add) & mask
\layout LyX-Code

endm 
\layout Section

module
\begin_inset LatexCommand \index{module}

\end_inset 


\layout Standard

The 
\emph on 
module
\emph default 
 command is used to load and query external modules.
 A module is a special piece of software that can extend gpsim in some manner.
 LED's and switches are examples of modules.
 A module library is collection of modules.
\layout Subsubsection*

Loading module libraries
\layout LyX-Code

module lib 
\emph on 
lib_name
\layout Standard

The 
\emph on 
lib
\emph default 
 option is used to load a module library.
 Module libraries are system dependent shared libraries.
 I.e.
 on Windows they're DLL's and UNIX they're shared libraries.
 This means that either the libraries should reside in a path where the
 OS knows libraries exist or that the full path name must be specified along
 with the 
\emph on 
lib_name
\emph default 
.
 gpsim provides a module library with a few modules:
\layout LyX-Code

gpsim> module lib libgpsim_modules
\layout Subsubsection*

Displaying available modules
\layout LyX-Code

module list
\layout Standard

The 
\emph on 
list
\emph default 
 option will display all of the modules that can be loaded.
 Here is an example of gpsim's built-in modules.
\layout LyX-Code

gpsim> module list
\layout LyX-Code

Module Libraries libgpsim_modules.so
\layout LyX-Code

   binary_indicator
\layout LyX-Code

   pullup
\layout LyX-Code

   pulldown
\layout LyX-Code

   usart
\layout LyX-Code

   parallel_interface
\layout LyX-Code

   switch
\layout LyX-Code

   and2
\layout LyX-Code

   or2
\layout LyX-Code

   xor2
\layout LyX-Code

   not
\layout LyX-Code

   led_7segments
\layout LyX-Code

   led
\layout LyX-Code

   PAL_video
\layout LyX-Code

   Encoder 
\layout Subsubsection*

Loading a specific module 
\layout LyX-Code

module load module_type [module_name]
\layout Standard

Once a library has been loaded, specific modules can be instantiated.
 The 
\emph on 
module_type
\emph default 
 is what's displayed by the 
\emph on 
module list
\emph default 
 command.
 The optional module name Here's an example 
\layout LyX-Code

gpsim> module load led D1 
\layout Subsubsection*

Display loaded modules
\layout Subsubsection*

Querying modules
\layout LyX-Code

\layout Section

node
\begin_inset LatexCommand \index{node}

\end_inset 


\layout LyX-Code

node [new_node1 new_node2 ...]
\layout LyX-Code

     If no new_node is specified then all of the nodes that have been
\layout LyX-Code

    defined are displayed.
 If a new_node is specified then it will be
\layout LyX-Code

    added to the node list.
 See the "attach" and "stimulus" commands
\layout LyX-Code

    to see how stimuli are added to the nodes.
\layout LyX-Code

 
\layout LyX-Code

    examples:
\layout LyX-Code

 
\layout LyX-Code

    node           // display the node list
\layout LyX-Code

    node n1 n2 n3  // create and add 3 new nodes to the list 
\layout Section

processor
\begin_inset LatexCommand \index{processor}

\end_inset 


\layout LyX-Code

processor [new_processor_type [new_processor_name]] | [list] | [dump] 
\layout Standard

The 
\emph on 
processor
\emph default 
 command is used to either define a new processor or to query one that has
 already been defined.
 Normally there's no need to explicitly define the processor since the symbol
 file already contains that information.
 The two exceptions are when a) the symbolic information is not available
 or b) you wish to override the processor specified in the symbol file.
 (See the 
\emph on 
load
\emph default 
 command on how the processor in a symbol file can be overridden.)
\layout Standard

To see a list of the processors supported by gpsim, type '
\emph on 
processor list
\emph default 
'.
 To display the state of the I/O processor, type '
\emph on 
processor pins
\emph default 
'.
 For now, this will display the pin numbers and their current state.
\layout LyX-Code

examples:
\layout LyX-Code

processor        // Display the processors you've already defined.
 
\layout LyX-Code

processor list   // Display the list of processors supported.
 
\layout LyX-Code

processor pins   // Display the processor package and pin state 
\layout LyX-Code

processor p16cr84 fred   // Create a new processor.
 
\layout LyX-Code

processor p16c74 wilma   // and another.
 
\layout LyX-Code

processor p16c65         // Create one with no name.
\layout Section

quit
\begin_inset LatexCommand \index{quit}

\end_inset 


\layout Standard

Quit gpsim.
\layout Section

run
\begin_inset LatexCommand \index{run}

\end_inset 


\layout Standard

Start (or continue) simulation.
 The simulation will continue until the next break point is encountered.
\layout Section

step
\begin_inset LatexCommand \index{step}

\end_inset 


\layout LyX-Code

step [over | n]
\layout LyX-Code

 
\layout LyX-Code

     no arguments:  step one instruction.
\layout LyX-Code

 numeric argument:  step a number of instructions 
\layout LyX-Code

  "over" argument:  step over the next instruction
\layout Section

symbol
\begin_inset LatexCommand \index{symbol}

\end_inset 


\layout LyX-Code

symbol [symbol_name [symbol_type value]] 
\layout Standard

The symbol command is used to query and define symbols.
 If no options are specified, the whole symbol table is displayed.
 The creation of user defined symbols is limited at this time (see the online
 help for the current state of this command).
\layout Section

stimulus
\begin_inset LatexCommand \index{stimulus}

\end_inset 


\layout LyX-Code

stimulus [[type] options]
\layout Standard

The 
\emph on 
stimulus
\emph default 
 command creates a signal that can be tied to a node or an attribute.
 If no options are specified then all currently defined stimuli are displayed.
 
\layout Standard

Note that in most cases it is easier to create a stimulus file then to type
 the command by hand.
 
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="5" columns="2">
<features islongtable="true" firstHeadEmpty="true" headBottomDL="true">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true" endhead="true" endfirsthead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

option
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

description
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

initial_state
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

state at the start and at the rollover
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

start_cycle
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

simulation cyle when the stimulus will begin
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

period
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

stimulus period 
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

name
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

specifies the stimulus name
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard

Here's an example of a stimulus that will generate two pulses and repeat
 this in 1000 cycles.
\layout LyX-Code

stimulus asynchronous_stimulus
\layout LyX-Code

\layout LyX-Code

# The initial state AND the state the stimulus is when 
\layout LyX-Code

# it rolls over
\layout LyX-Code

\layout LyX-Code

initial_state 0
\layout LyX-Code

start_cycle 0
\layout LyX-Code

\layout LyX-Code

# the asynchronous stimulus will roll over in 'period'
\layout LyX-Code

# cycles.
 Delete this line if you don't want a roll over.
\layout LyX-Code

\layout LyX-Code

period 1000
\layout LyX-Code

\layout LyX-Code

{ 100, 1,
\layout LyX-Code

  200, 0,
\layout LyX-Code

  300, 1,
\layout LyX-Code

  400, 0 
\layout LyX-Code

}
\layout LyX-Code

# Give the stimulus a name:
\layout LyX-Code

\layout LyX-Code

name two_pulse_repeat
\layout LyX-Code

\layout LyX-Code

end
\layout Standard

A stimulus can be queried by typing its name at the command line:
\layout LyX-Code

gpsim> two_pulse_repeat 
\layout LyX-Code

two_pulse_repeat attached to pulse_node
\layout LyX-Code

  Vth=0V  Zth=250 ohms  Cth=0 F  nodeVoltage= 7.49998e-07V 
\layout LyX-Code

  Driving=0 drivingState=0 drivenState=0 bitState=0
\layout LyX-Code

\layout LyX-Code

  states = 5
\layout LyX-Code

    100 1
\layout LyX-Code

    200 0
\layout LyX-Code

    300 1
\layout LyX-Code

    400 0
\layout LyX-Code

    1000 0   
\layout LyX-Code

initial=0   
\layout LyX-Code

period=1000   
\layout LyX-Code

start_cycle=0   
\layout LyX-Code

Next break cycle=100 
\layout Standard

Even though this example uses 1's and 0's for the data, one can use integers,
 floating point numbers, or expressions instead.
 Integers are useful for supplying a stimulus to an attribute.
 Expressions are useful for abstracting the data.
 See Chapter 
\begin_inset LatexCommand \ref{cha:Simulating-the-Real}

\end_inset 

 for more discussion and examples of stimuli.
\layout Section

stopwatch
\begin_inset LatexCommand \index{stopwatch}

\end_inset 


\layout Section

trace
\begin_inset LatexCommand \index{trace}

\end_inset 


\layout LyX-Code

trace [dump_amount]
\layout LyX-Code

      trace will print out the most recent "dump_amount" traces.
\layout LyX-Code

      If no dump_amount is specified, then the entire trace buffer
\layout LyX-Code

      will be displayed.
\layout Section

version
\layout LyX-Code

version
\layout Standard

Display gpsim's version.
 Note, this command will probably get replaced by an attribute with the
 same (or similar) name.
\layout Section

x
\begin_inset LatexCommand \index{x}

\end_inset 


\layout LyX-Code

x [file_register] [new_value]
\layout LyX-Code

  options:
\layout LyX-Code

    file_register - ram location to be examined or modified.
\layout LyX-Code

    new_value - the new value written to the file_register.
\layout LyX-Code

    if no options are specified, then the entire contents
\layout LyX-Code

    of the file registers will be displayed (dump).
\layout LyX-Code

 
\layout Chapter


\begin_inset LatexCommand \label{cha:Graphical-User-Interface}

\end_inset 

Graphical User Interface
\layout Standard

gpsim also provides a graphical user interface that simplifies some of the
 drudgery associated with the cli.
 It's possible to open windows to view all the details about your debug
 environment.
 To get the most out of your debugging session, you'll want to assemble
 your code with gpasm (the gnupic assembler) and use the symbolic .cod files
 it produces.
\layout Section

Main window
\layout Subsection

Menus
\layout List
\labelwidthstring 00000000.00.0000

File->Open .stc or .cod files.
\layout List
\labelwidthstring 00000000.00.0000

File->Quit Quit gpsim
\layout List
\labelwidthstring 00000000.00.0000

Windows->* Open/Close the windows.
\layout Subsection

Buttons
\layout Standard

(These are also found as keyboard bindings in the source windows.)
\layout List
\labelwidthstring 00000000.00.0000

Step Step one instruction
\layout List
\labelwidthstring 00000000.00.0000

Over Step until pc is after next instruction
\layout List
\labelwidthstring 00000000.00.0000

Finish Run to return address
\layout List
\labelwidthstring 00000000.00.0000

Run Run continuously
\layout List
\labelwidthstring 00000000.00.0000

Stop Stop execution
\layout List
\labelwidthstring 00000000.00.0000

Reset Reset CPU
\layout Subsection

Simulation mode
\layout Standard

This controls how gpsim simulates, and how the gui updates.
\layout List
\labelwidthstring 0000000.00.0000

Never Don't ever update the gui when simulating.
 This is the fastest mode.
 You'll have to stop simulation by pressing Ctrl-C in the command line interface.
\layout List
\labelwidthstring 0000000.00.0000

x\SpecialChar ~
cycles Update the gui every x cycles simulated.
\layout List
\labelwidthstring 0000000.00.0000

every\SpecialChar ~
cycle Update the gui every cycle.
 (you see everything, if you have filled up on coffee :-)
\layout List
\labelwidthstring 0000000.00.0000

x\SpecialChar ~
ms\SpecialChar ~
animate Here you can slow down simulation with a delay between every
 cycle.
\layout List
\labelwidthstring 0000000.00.0000

realtime This will make gpsim try to synchronize simulation speed with wall
 clock time.
\layout Section

Source Browsers
\layout Standard

gpsim provides two views of your source: '.
\emph on 
asm'
\emph default 
 and '.
\emph on 
obj' 
\emph default 
browsers.
 The '.
\emph on 
asm' 
\emph default 
browser is a color coded display of your pic source.
 
\layout Subsection

.asm Browser
\layout Standard

When a .cod file with source is loaded, there should be something in this
 display.
 (TODO: add section about high level debugging).
\layout Standard

There is an area to the left of the source, where symbols representing the
 program counter, breakpoints, etc are displayed.
 Double clicking in this area toggles breakpoints.
 You can drag these symbols up or down in order to move them and change
 the PC or move a breakpoint.
\layout Standard

A right button click on the source pops up a menu with six items (the word
 'here' in some menu items denote the line in source the mouse pointer was
 on when right mouse button was clicked.):
\layout List
\labelwidthstring 00.00.0000.0000


\series bold 
Menu\SpecialChar ~
item Description
\layout List
\labelwidthstring 00.00.0000.0000

Find\SpecialChar ~
PC This menu item will find the PC and changed page tab and scroll the
 source view to the current PC.
\layout List
\labelwidthstring 00.00.0000.0000

Run\SpecialChar ~
here This sets a breakpoint 'here'and starts running until a breakpoint
 is hit.
\layout List
\labelwidthstring 00.00.0000.0000

Move\SpecialChar ~
PC\SpecialChar ~
here This simply changes PC to the address that line 'here'in source
 has.
\layout List
\labelwidthstring 00.00.0000.0000

Breakpoint\SpecialChar ~
here Set a breakpoint 'here'.
\layout List
\labelwidthstring 00.00.0000.0000

Profile\SpecialChar ~
start\SpecialChar ~
here Set a start marker for routine profiling here.
\layout List
\labelwidthstring 00.00.0000.0000

Profile\SpecialChar ~
stop\SpecialChar ~
here Set a stop marker.
 (See the section for the profiling window.)
\layout List
\labelwidthstring 00.00.0000.0000

Select\SpecialChar ~
symbol.
 This menu item is only available when some text is selected in the text
 widget.
 What it does is search the list of symbols for the selected word, and if
 it is found it is selected in the symbol window.
 Depending of type of symbol other things are also done, the same thing
 as when selecting a symbol in the symbol window: 
\begin_deeper 
\layout Itemize

If it is an address, then the opcode and source views display the address.
 
\layout Itemize

If it's a register, the register viewer selects the cell.
\layout Itemize

If it's a constant, address, register or ioport, it is selected in the symbol
 window.
\end_deeper 
\layout List
\labelwidthstring 00.00.0000.0000

Find\SpecialChar ~
text This opens up a search dialog.
 Every time you hit the 'Find' button, the current notebook page is found
 and the source in that page is used.
\layout List
\labelwidthstring 00.00.0000.0000

Settings A dialog with which you can change the fonts used.
\layout List
\labelwidthstring 00.00.0000.0000

Controls A submenu containing the simulation commands.
 (these are also found as keyboard bindings (recommended), or in the main
 window.)
\layout Standard

These are the keyboard bindings:
\layout List
\labelwidthstring 00.00.0000


\series bold 
Key command
\layout List
\labelwidthstring 00.00.0000

s,S,F7 Step one instruction.
\layout List
\labelwidthstring 00.00.0000

o,O,F8 Step over instruction
\layout List
\labelwidthstring 00.00.0000

r,R,F9 Run continously.
\layout List
\labelwidthstring 00.00.0000

Escape Stop simulation.
\layout List
\labelwidthstring 00.00.0000

f,F Run to return address
\layout Subsection

Opcode view - the .obj Browser
\layout Standard

This window has two tabs.
 One with each memory cell on one line and information about address, hexadecima
l value and decoded instruction (i.e.
 disassembly), and one with the program memory
\layout Standard

displayed with sixteen memory cells per row and a configurable ascii column.
\layout Subsubsection*

The Assembly tab you can:
\layout Itemize

Double click on a line to toggle breakpoints.
\layout Itemize

Use the same keyboard commands as the in the source browser.
\layout Itemize

Right click to get a menu where you can change the fonts.
\layout Subsubsection*

The Opcode tab.
\layout Standard

Here the program memory is ordered as columns of sixteen memory cells per
 column and as many row as needed to contain all memory.
 
\layout Standard

The seventeenth column contains an ASCII representation of the program memory.
 You can configure this column to use one of three different modes:
\layout Itemize

One byte per cell
\layout Itemize

Two bytes per cell, MSB first.
\layout Itemize

Two bytes per cell, LSB first.
\layout Standard

You can change fonts with the menu item 'Settings'.
\layout Standard

You can set breakpoints on one or more (drag the mouse to select more cells)
 addresses with the right click menu.
\layout Section

Register views
\layout Standard

There are two similar register windows.
 One for the RAM and one for the EEPROM data, when available.
\layout Standard

Here you see all registers in the current processor.
 Clicking on a cell displays it's name and value above the sheet of registers.
 You can change values by entering it in the entry (or in the spreadsheet
 cell).
\layout Standard

The following things can be done on one register, or a range of registers.
 (Selecting a range of registers is done by holding down left mouse button,
 moving cursor, and releasing button.)
\layout Itemize

Set and clear breakpoints.
 Use the right mousebutton menu to pop up a menu where you can select set
 read, write, read value and write value breakpoints.
 You can also "clear breakpoints", notice the s in "clear breakpoints",
 every breakpoint on the registers are cleared.
 
\layout Itemize

Set and clear logging of registers.
 You can log reads, writes, reads/writes of specific values and to bits
 selected by a specified mask.
 You can select a different file name with 'set log filename...'.
 Default is "gpsim.log".
 You can choose LXT or ASCII format.
 LXT can be read with the program gtkwave.
 ASCII is default.
\layout Itemize

Copy cells.
 You copy cells by dragging the border of the selected cell(s).
\layout Itemize

Fill cells.
 Move mouse to lower right corner of the frame of the selected cell(s),
 and drag it.
 The one cell's contents will be copied to the other cells.
\layout Itemize

Watch them.
 Select the "Add Watch" menu item.
\layout Standard

The cells have different background colors depending on if they represent:
\layout Itemize

File Register (e.g.
 RAM): light cyan.
\layout Itemize

Special Function Registers (e.g.
 STATUS,TMR0): dark cyan
\layout Itemize

aliased register (e.g.
 the INDF located at address 0x80 is the same as the one located at address
 0x00): gray
\layout Itemize

invalid register: black.
 If all sixteen registers in a row are invalid, then the row is not shown.
\layout Itemize

a register with one or more breakpoints: red.
 Logged registers are also red.
\layout Standard

gpsim dynamically updates the registers as the simulation proceeds.
 Registers that change value between updates of the window during simulation
 are highlighted with a blue foreground color.
 
\layout Standard

The menu also has a 'settings' item where you can change the font used.
\layout Section

Symbol view
\layout Standard

This window, as its name suggests, displays symbols.
 All of the special function registers will have entries in the symbol viewer.
 If you're using .cod files then you'll additionally have file registers
 (that are defined in cblocks), equates, and address labels.
\layout Standard

You can filter out some symbol types using the buttons in the top of the
 window, and you can sort the rows by clicking on the column buttons (the
 ones reading 'symbol', 'type' and 'address').
\layout Standard

You can add the symbol to the watch window by right-clicking and selecting
 the "Add to watch window" menu item.
 This will add the ram register with address equal to the symbols value
 to the watch window.
\layout Standard

The symbol viewer is linked to the other windows.
 For example, if you click on a symbol and:
\layout Itemize

If it is an address, then the opcode and source views display the address.
\layout Itemize

If it's a register, the register viewer selects the cell.
\layout Section

Watch view
\layout Standard

This is not a output-only window as the name suggests (change name?).
 You can both view and change data.
 Double-clicking on a bit toggles the bit.
 You add variables here by marking them in a register viewer and select
 
\begin_inset Quotes eld
\end_inset 

Add watch
\begin_inset Quotes erd
\end_inset 

 from menu.
 The right-click menu has the following items:
\layout Itemize

Remove watch
\layout Itemize

Set register value
\layout Itemize

Clear Breakpoints
\layout Itemize

Set break on read
\layout Itemize

Set break on write
\layout Itemize

Set break on read value
\layout Itemize

Set break on write value
\layout Itemize

Columns...
 
\layout Standard

"Columns...
\begin_inset Quotes erd
\end_inset 

 opens up a window where you can select which of the following data to display:
\layout Itemize

BP
\layout Itemize

Type
\layout Itemize

Name
\layout Itemize

Address
\layout Itemize

Dec
\layout Itemize

Hex
\layout Itemize

Bx (bits of word)
\layout Standard

You can sort the list of watches by clicking on the column buttons.
 Clicking twice sorts the list backwards.
\layout Section

Stack viewer
\layout Standard

This window displays current stack.
 Selecting an entry makes the code windows display the return address.
 Double clicking sets a breakpoint on the return address.
\layout Section

Breadboard
\layout Standard

Here you can create/modify and examine the environment around the pic.
 Pins are displayed as an arrow.
 The direction of the arrow indicates if its an input or output pin.
 The color of the arrow indicates its state (green=low, red=high).
\layout Standard

You can't instantiate pic processors from here, you'll have to do that from
 the command line, or from a .stc file.
\layout Standard

Your can create nodes by clicking on the "new node" button.
 (A node is 'a piece of wire' to which you can connect stimulus.) You can
 see the list of created nodes under the "nodes" item in the upper-left
 tree widget.
\layout Standard

You can create connections to nodes by clicking on a pin, and then clicking
 on the button "Connect stimulus to node".
 This will bring up a list of nodes.
 Choose one by double-clicking on the one you like.
\layout Standard

If you click on a pin that is already connected to a node, then you'll see
 the node and its connections in the lower left part of the window.
 You can disconnect a stimulus by clicking on it and pressing the "remove
 stimulus" button.
\layout Standard

When you want to add a module to the simulation, you first have to specify
 the library which contains the module you want.
 Click on the "add library" button and enter the library name (e.g.
 "libgpsim_modules.so").
 Now you can click the "add module" button.
 Select the module you want from the list by double-clicking on it.
 Enter a name for the module (this has to be unique, and not used before).
 You now have to position the module.
 Move the mouse pointer to where you'd like the module, and left-click.
\layout Standard

If you middle-click on a pin, you'll see how the pin is connected.
 Press the "trace all" to see all at
\layout Standard

once, and "clear traces" to remove all (you'll only remove the graphical
 trace, not the connection!).
 If the tracing doesn't work, try moving the packages so that there are
 more space around the pins.
\layout Standard

When you are done, you can save by clicking the "save configuration" button.
 You can then load this file from the command line like this (assuming the
 .cod file with your source is called "mycode.cod", and the file you just
 saved was called "mynets.stc":
\layout Standard

gpsim -s mycode.cod -c mynets.stc
\layout Standard

You can't load only the .stc file since this doesn't contain the processor
 type and code.
 You can create (with an editor) your own .stc file (e.g.
 my_project.stc) and in that file put a command "load c mynets.stc" after
 you have loaded the .cod file.
 You then only have to load this file (gpsim -c my_project.stc).
\layout Section

Trace viewer
\layout Standard

This window shows the trace of instructions executed.
 See 
\begin_inset LatexCommand \ref{trace}

\end_inset 

.
\layout Section

Profile viewer
\layout Standard

This window show execution count for program memory addresses.
 The profile window must be opened before starting simulation, because the
 traceing is not enabled by default.
\layout Subsubsection

Instruction profile
\layout Standard

This shows the number of times each instruction are executed.
\layout Subsubsection

Instruction range profile
\layout Standard

Here you can group ranges of instruction into one entry.
 
\layout Standard

The right click menu contains:
\layout List
\labelwidthstring 00000000.00.0000

Remove\SpecialChar ~
range Remove an entry.
\layout List
\labelwidthstring 00000000.00.0000

Add\SpecialChar ~
range...
 Open a disalog from where you can add a range of instructions as an entry.
\layout List
\labelwidthstring 00000000.00.0000

Add\SpecialChar ~
all\SpecialChar ~
labels Add all code labels as ranges.
\layout List
\labelwidthstring 00000000.00.0000

Snapshot\SpecialChar ~
to\SpecialChar ~
plot Open a window containing a graph of the data.
 From this new window you can also save (postscript) or print it.
\layout Subsubsection*

Register profile
\layout Standard

This shows the number of reads or writes the simulator does on register.
\layout Subsubsection*

Routine profile
\layout Standard

Here you can see statistics about execution time for a selected routine.
 You mark the entry and exit points from the source browser (profile start/stop).
 If the routine you want to measure have multiple entry and/or exit points,
 then you have to put a marker on every entry point as well as (and especially)
 every exit point.
 Othervise you will get bad data.
 
\layout Standard

When you have done that, gpsim will (as simulation goes by) store the execution
 times of that routine and calculate min/max/average/etc.
 You can also use the menu item 'Plot distribution' to open a window displaying
 a histogram of the data.
 From this new window you can also save (in postscript) or print it.
\layout Standard

You can also measure call period by switching the 'entry' and 'exit' points.
 If also want the time from reset (or some equal point) to the first 'entry',
 then you must also put an 'entry' point there.
\layout Section

Stopwatch
\layout Standard

The stopwatch window shows a cycle counter and a re-settable counter.
 The cycle counter is the same as the one in the register window.
 It basically counts instructions.
 
\layout Standard

The other counter counts at the same rate as the cycle counter, but can
 be cleared by clicking the "clear" button (or preset by entering a number
 in the entry box).
 
\layout Standard

The up/down indicator denotes the direction the counter counts.
\layout Standard

The rollover value specifies the range the cycle counter can be in (a modulo
 counter).
 For example, if the rollover value is specified to be 0x42, then whenever
 the resettable counter reaches 0x42 it will rollover to zero.
 If the counter is counting down, then when it reaches 0 the next state
 will be 0x41.
 If you don't want is like this, then set the rollover value to something
 large.
\layout Chapter


\begin_inset LatexCommand \label{cha:Assertions-and-Extended}

\end_inset 

Assertions and Extended Breakpoints
\layout Standard

gpsim supports a wide variety of breakpoints and assertions.
 Many of these were described with the break command.
 This section will illustrate how to extend the break command even further
 and introduce simulation assertions.
 
\layout Subsection*

Breakpoint Messages
\layout Standard

A breakpoint message is an ASCII string that is displayed whenever a breakpoint
 is encountered.
 Any break point can have an associated message.
 The syntax at the command line is
\layout LyX-Code

break conditions, 
\begin_inset Quotes eld
\end_inset 


\emph on 
This is a breakpoint message
\emph default 

\begin_inset Quotes erd
\end_inset 


\layout Standard

The conditions are described above in the break command and are the conditions
 under which the break occurs.
 
\layout Standard

Breakpoint messages are useful for distinguishing among many different breakpoin
ts.
 
\layout LyX-Code

break w counter & 0xf0 == 0x80, 
\begin_inset Quotes eld
\end_inset 

Counter overflowed!
\begin_inset Quotes erd
\end_inset 


\layout Standard

In this example, the user is monitoring the upper nibble of the variable
 counter and breaking whenever it is equal to 8.
 When the command is entered, gpsim will display:
\layout LyX-Code

break when bit pattern 1000XXXX is written to register counter(0x26).
 break #: 0x20 
\layout Standard

The breakpoint can be queried with the break command:
\layout LyX-Code

gpsim> 
\emph on 
break 32
\layout LyX-Code

32: p18f452 register write value: [0x26] & 0xf0 == 0x8
\layout LyX-Code

    Message:Counter overflowed!
\layout Standard

When the simulation encounters the break, execution halts and the message
 is printed.
\layout Subsection*

Assertions
\layout Standard

discuss how simulation assertions are embedded in .asm source.
\layout Subsection*

Command Assertions
\layout Standard

discuss how a gpsim command can be embedded in the .asm source.
 Explain how the command executes everytime the instruction it's associated
 with is executed.
\layout Subsection*

Embedded Simulation Scripts
\layout Standard

refer to the section on gpsim configuration scripts.
 Explain how a script can be embedded in the asm source code.
 Explain how this is different from a command assertion; in other words
 the embedded scripts are extracted from the source whenever the source
 is loaded.
 This collection of commands is then invoked all at once - just before control
 is given over to the user.
\layout Chapter

Trace: What has happen?
\begin_inset LatexCommand \label{trace}

\end_inset 


\layout Standard

Inspecting the current state of your program is sometimes insufficient to
 determine the cause of a bug.
 Often times it's useful to know the conditions that led up to the current
 state.
 gpsim provides a history or trace of everything that occurs - whether you
 want it or not - to help you diagnose these otherwise difficult to analyze
 bugs.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center 

\begin_inset  Tabular
<lyxtabular version="3" rows="13" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" width="0pt">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0pt">
<row topline="true" bottomline="true">
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

What's traced
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

notes
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

program counter
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

adresses executed
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

instructions
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

opcode
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

register read
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

value and location
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

register write
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

value and location
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

cycle counter
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

current value
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

skipped instructions
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

addresses skipped
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

status register
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

during implicit modification
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

interrupts
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

break points
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

type
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

resets
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

type
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard

The 'trace' command will dump the contents of the trace buffer.
 
\layout Standard

A large circular buffer (whose size is hard coded) stores the information
 for the trace buffer.
 When it fills, it will wrap around and write over the old history.
 The contents of the trace buffer are parsed into frames, where one frame
 corresponds to a simulation cycle.
\layout Standard

Here's an example of a trace output:
\layout LyX-Code

gpsim> trace
\layout LyX-Code

0x00000000000026F6 p18f452 0x001C 0x1003 iorwf  reg3,w,0
\layout LyX-Code

   Read: 0x00 from reg3(0x0003)
\layout LyX-Code

  Wrote: 0xE7 to W(0x0FE8) was 0xE7
\layout LyX-Code

  Wrote: 0x18 to status(0x0FD8) was 0x18
\layout LyX-Code

0x00000000000026F7 p18f452 0x001E 0xE1F4 bnz    $-0x16  ;(0x8)
\layout LyX-Code

0x00000000000026F8 p18f452 0x0008 0x3E00 incfsz reg,f,0
\layout LyX-Code

   Read: 0xE4 from reg(0x0000)
\layout LyX-Code

  Wrote: 0xE5 to reg(0x0000) was 0xE4
\layout LyX-Code

0x00000000000026F9 p18f452 0x000A 0xD004 bra    $+0xa   ;(0x00014) 0x00000000000
026FA p18f452 0x0014 0x0004 clrwdt
\layout LyX-Code

0x00000000000026FB p18f452 0x0016 0x5000 movf   reg,w,0
\layout LyX-Code

   Read: 0xE5 from reg(0x0000)
\layout LyX-Code

  Wrote: 0xE5 to W(0x0FE8) was 0xE7
\layout LyX-Code

  Wrote: 0x18 to status(0x0FD8) was 0x18
\layout LyX-Code

0x00000000000026FC p18f452 0x0018 0x1001 iorwf  reg1,w,0
\layout LyX-Code

   Read: 0x03 from reg1(0x0001)
\layout LyX-Code

  Wrote: 0xE7 to W(0x0FE8) was 0xE5
\layout LyX-Code

  Wrote: 0x18 to status(0x0FD8) was 0x18 
\layout Standard

Each trace frame begins with a new simulation cycle.
 Typically this will include a simulated instruction.
 Here's each of the fields:
\layout LyX-Code


\begin_inset  Tabular
<lyxtabular version="3" rows="2" columns="5">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

64-bit simulation cycle
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

processor
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

PC
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

opcode
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

instruction
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0x00000000000026F6
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

p18f452
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0x001C
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0x1003
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

iorwf  reg3,w,0
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard

Other events that occur during the trace frame are indented.
 Typically these will be register read or write traces.
 The read traces show the value read.
 Write traces show the value written and the value that was previously in
 the register.
\layout Chapter


\begin_inset LatexCommand \label{cha:Simulating-the-Real}

\end_inset 

Simulating the Real World: Stimuli
\begin_inset LatexCommand \index{Stimulus}

\end_inset 


\layout Standard

Stimuli are extremely useful, if not necessary, for simulations.
 They provides a means for simulating interactions with the real world.
 
\layout Standard

The gpsim stimuli capability is designed to be accurate, efficient and flexible.
 The models for the PIC's I/O pins mimic the real devices.
 For example, the open collector output on port A of an PIC16C84 can only
 drive low.
 Multiple I/O pins may tied to one another so that the open collector on
 port A can get a pull up resistor from port B.
 The overhead for stimuli only occurs when a stimulus changes states.
 In other words, stimuli are not polled to determine their state.
\layout Standard

Analog stimuli are also available.
 It's possible to create voltage references and sources to simulate almost
 any kind of real world thing.
 For example, it's possible to combine two analog stimuli together to create
 signals like DTMF tones.
 
\layout Section

How They Work
\layout Standard

In the simplest case, a stimulus acts a source for an I/O pin on a pic.
 For example, you may want to simulate a clock and measure its period using
 TMR0.
 In this case, the stimulus is the source and the TMR0 input pin on the
 pic is the load.
 In gpsim you would create a stimulus for the clock using the stimulus command
 and connect it to the I/O pin using the node command.
 
\layout Standard

In general, you can have several 'sources' and several 'loads' that are
 interconnected with nodes
\begin_inset Foot
collapsed true

\layout Standard

Although, gpsim is currently limited to 'one-port' devices.
 In other words, it is assumed that ground serves as a common reference
 for the sources and the loads.
\end_inset 

.
 A good analogy is a spice circuit.
 The spice netlist corresponds to a node-list in gpsim and the spice elements
 correspond to the stimuli sources and loads.
 This general approach makes it possible to create a variety of simulation
 environments.
 Here's a list of different ways in which stimuli may be connected:
\layout Enumerate

Stimulus connected to one I/O pin
\layout Enumerate

Stimulus connected to several I/O pins
\layout Enumerate

Several stimuli connected to one I/O pin
\layout Enumerate

Several stimuli connected to several I/O pins
\layout Enumerate

I/O pins connected to I/O pins
\layout Standard

The general technique for implementing stimuli is as follows:
\layout Enumerate

Define the stimulus or stimuli.
\layout Enumerate

Define a node.
\layout Enumerate

Attach the stimuli to the node.
\layout Standard

More often then not, the stimulus definition will reside in a file.
\layout Subsection

Contention among stimuli
\layout Standard

One of the problems with this nodal approach to modeling stimuli is that
 it's possible for contention to exist.
 For example, if two I/O pins are connected to one another and driving in
 the opposite directions, there will be contention.
 gpsim resolves contention with attribute summing.
 Each stimulus - even if it's an input - has an effect on the node.
 This effect is given a weight.
 When a node is updated, gpsim will simply add the weights of all the stimuli
 together and assign that numeric value to the node.
 A weight value of zero corresponds to no load.
 A large positive weight is used by a stimulus to drive the node positive,
 while a large negative weight is used to drive it negative.
 
\layout Standard

Attribute summing is useful for pull up resistors.
 In the port A open collector / port B weak pull-up connection example,
 gpsim assigns a relatively small weight to the pull up resistor and a large
 negative weight to the open collector if it is active or no weight if it's
 not driving.
 Capacitive effects (which are not currently supported) can be simulated
 with dynamically changing weight values.
\layout Section

I/O Pins
\layout Standard

gpsim models I/O pins as stimuli.
 Thus anywhere a stimulus is used, an I/O pin may be substituted.
 For example, you may want to tie two I/O pins to one another; like a port
 B pull up resistor to a port A open collector.
 gpsim automatically creates the I/O pin stimuli whenever a processor is
 created.
 All you need to do is to specify a node and then attach the stimuli to
 it.
 The names of these stimuli are formed by concatenating the port name with
 the bit position of the I/O pin.
 For example, bit 3 in port B is called portb3.
\layout Standard

Here's a list of the types of I/O pin stimuli that are supported:
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center 

\begin_inset  Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" width="0pt">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0pt">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

I/O Pin Type
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Function
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

INPUT_ONLY
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Only accepts input (like MCLR)
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

BI_DIRECTIONAL
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Can be a source or a load (most I/O pins)
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

BI_DIRECTIONAL_PU
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

PU=Pullup resistor (PORTB)
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

OPEN_COLLECTOR
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Can only drive low (RA4 on c84)
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard

There is no special pin type for analog I/O pins.
 All pic analog inputs are multiplexed with digital inputs.
 The I/O pin definition will always be for the digital input.
 gpsim automatically knows when I/O pin is analog input.
\layout Section

Asynchronous Stimuli
\layout Standard

Asynchronous stimuli are analog or digital stimuli that can change states
 at any given instant (limited to the resolution of the cycle counter).
 They can be defined to be repetitive too.
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center 

\begin_inset  Tabular
<lyxtabular version="3" rows="6" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" width="0pt">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0pt">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

parameter
\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

function
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

start_cycle
\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

The # of cycles before the stimulus starts
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

cycles[]
\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

An array of cycle #'s
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

data[]
\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Stimulus state for a cycle
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

period
\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

The # of cycles for one period
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

initial_state
\end_inset 
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

The initial state before data[0]
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard

When the stimulus is first initialized, it will be driven to the 'initial
 state' and will remain there until the cpu's instruction cycle counter
 matches the specified 'start' cycle.
 After that, the two arrays 'cycles[]' and 'data[]' define the stimulus'
 outputs.
 The size of the arrays are the same and correspond to the number of events
 that are to be created.
 So the event number, if you will, serves as the index into these arrays.
 The 'cycles[]' array define when the events occur while the 'data[]' array
 defines the states the stimulus will enter.
 The 'cycles[]' are measured with respect to the 'start' cycle.
 The asynchronous stimulus can be made periodic by specifying the number
 of cycles in the 'period' parameter.
\layout Standard

Here's an example that generates three pulses and then repeats:
\layout LyX-Code

stimulus asynchronous_stimulus # or we could've used asy
\newline 

\layout LyX-Code

# The initial state AND the state the stimulus is when
\layout LyX-Code

# it rolls over
\newline 

\layout LyX-Code

initial_state 1
\newline 

\layout LyX-Code

# all times are with respect to the cpu's cycle counter
\layout LyX-Code

start_cycle 100
\newline 

\layout LyX-Code

# the asynchronous stimulus will roll over in 'period'
\newline 
# cycles.
 Delete this line if you don't want a roll over.
\layout LyX-Code

period 5000
\newline 

\layout LyX-Code

# Now the cycles at which stimulus changes states are 
\layout LyX-Code

# specified.
 The initial cycle was specified above.
 So 
\newline 
# the first cycle specified below will toggle this state.
 
\layout LyX-Code

# In this example, the stimulus will start high.
 
\layout LyX-Code

# At cycle 100 the stimulus 'begins'.
 However nothing happens
\layout LyX-Code

# until cycle 200+100.
\layout LyX-Code

{ 200, 0,
\layout LyX-Code

  300, 1,
\layout LyX-Code

  400, 0,
\layout LyX-Code

  600, 1,
\layout LyX-Code

  1000, 0, 
\layout LyX-Code

  3000, 1 }
\layout LyX-Code

\layout LyX-Code

# Give the stimulus a name:
\layout LyX-Code

name asy_test
\newline 

\layout LyX-Code

# Finally, tell the command line interface that we're done
\layout LyX-Code

# with the stimulus
\layout LyX-Code

end
\layout Subsection

Analog Asynchronous Stimuli
\layout Standard

Analog Asynchronous Stimuli are identical to Synchronous Stimuli except
 the data points are floating point numbers.
 
\layout Chapter

Modules
\layout Standard

gpsim has been designed to debug microprocessors.
 However, microprocessors are always a part of a system.
 And invariably, the bugs one often encounters are those that are a result
 of interfacing with a system.
 Modules provide users with a way to extend gpsim and simulate a system.
 For example, the 
\emph on 
system
\emph default 
 may be a processor with a few pull up resistors and switches or it may
 be a processor and an LCD display.
 gpsim provides a few modules that one may use either for debugging or as
 templates for creating new modules.
\layout Section

gpsim Modules
\layout Standard

gpsim provides the following modules:
\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="15" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

binary_indicator
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

pullup
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

pulldown
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

usart
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

parallel_interface
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

switch
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

and2
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

or2
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

xor2
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

not
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

led_7segments
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

led 
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

PAL_video
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Encoder
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Section

Writing new modules
\layout Standard

A module is a library of code.
 On Windows the library is a .DLL and Unix a shared library.
 There are few details that module must adhere to, but in general the module
 has full access to gpsim's API.
\layout Chapter

Symbolic Debugging
\layout Standard

gpsim maintains a symbol table.
 
\layout Standard

<write me>
\layout Chapter

Macros
\layout Standard

<write me>
\layout Chapter

Hex Files
\layout Standard

The target code simulated by gpsim can be supplied by a hex file, or more
 specifically an Intel Hex file.
 gpsim accepts the format of hex provided by gpasm and mpasm.
 The hex file does not provide any symbolic information.
 It's recommended that hex files only be used if 1) you suspect there's
 a problem with the way .cod files are generated by your assembler or compiler
 OR 2) your assembler or compiler doesn't generate .cod files.
 Also, you must supply a processor when loading hex files.
 See the load command.
\layout Chapter

The ICD
\layout Standard

gpsim supports (partly) the first version of the ICD (as opposed to ICD2
 (the round hockey-puck shaped one)).
 
\layout Subsection*

Special configuration of the code
\layout Standard

Read the MPLAB ICD USER's GUIDE.
 
\layout Standard

Here's the short version:
\layout Itemize

disable at least: brown out detection, low voltage programming and all code
 protection.
 It is probably good to turn of the watchdog too.
 see the MPLAB ICD USER's GUIDE for more information.
 
\layout Itemize

have a NOP as the first instruction.
\layout Itemize

Don't touch RB6 or RB7.
\layout Itemize

Don't use the last stack level.
\layout Itemize

Don't use these registers and program words:
\newline 

\begin_inset  Tabular
<lyxtabular version="3" rows="4" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="0pt">
<column alignment="center" valignment="top" leftline="true" width="0pt">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0pt">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Processor
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Register
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Program
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

-870/1/2
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0x70, 0xBB-0xBF
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

0x6E0-0x7FF
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

-873/4
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0x6D, 0x1fD, 0xEB-0xF0, 0x1Eb-0x1F0
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

0xEE0-0xFFF
\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

-876/7
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

0x70, 0x1Eb-0x1Ef
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

0x1F00-0x1FFF
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Subsection*

icdprog
\layout Standard

Download and install icdprog.
 
\layout Standard

Use icdprog to program the target with the hex file (
\emph on 
icdprog mycode.hex
\emph default 
).
\layout Subsection*

ICD usage
\layout Standard

Start gpsim like this:
\layout Standard


\emph on 
gpsim -d /dev/ttyS0 -s mycode.cod
\layout Standard

, assuming the ICD is connected to the first serial port.
\layout Standard

Now you can type 'icd' to see some information:
\layout Standard


\emph on 
**gpsim> icd 
\newline 
ICD version "2.31.00" was found.
 
\newline 
Target controller is 16F877 rev 13.
 
\newline 
Vdd: 5.2 Vpp: 13.3 
\newline 
Debug module is present
\layout Standard

2.31 is the firmware version.
 I have only tried this particular version...
\layout Standard

You can step, reset, run, halt, set the breakpoint and read file registers.
 It works both from the gui and the cli.
\layout Subsection*

ICD TODO
\layout Itemize

MPLAB has a setting for target cpu frequency, I have only tried with a 20MHz
 crystal, so there may be adjustments to be made to the serial port timeout
 settings in gpsim.
\layout Itemize

The source, disassembly, watch, symbol and RAM windows works.
 And the rest doesn't.
 I guess the breadboard should be able to work at least for the pic, but
 it doesn't.
 
\layout Itemize

eeprom support 
\layout Itemize

modifying data 
\layout Itemize

Fix the UI to give more feedback about what's happening during long delays.
\layout Itemize

Better error detection.
 gpsim doesn't always see that the target is not functional.
\layout Chapter

Theory of Operation
\layout Standard

This section is only provided for those who may be interested in how gpsim
 operates.
 The information in here is 'mostly' accurate.
 However, as gpsim evolves so do the details of the theory of operation.
 Use the information provided here as a high level introduction and use
 the (well commented :]) source to learn the details.
\layout Section

Background
\layout Standard

gpsim is written mostly in C++.
 Why? Well the main reason is to easily implement a hierarchical model of
 a pic.
 If you think about a microcontroller, it's really easy to modularize the
 various components.
 C++ lends itself well to this conceptualization.
 Furthermore Microchip, like other microcontroller manufacturers, has created
 families of devices that are quite similar to one another.
 Again, the C++ provides 'inheritance' that allows the relationships to
 be shared among the various models of pics.
\layout Section

Instructions
\begin_inset LatexCommand \index{instructions}

\end_inset 


\layout Standard

There's a base class for the 14-bit instructions (I plan to go one step
 further and create a base class from which all pic instructions can be
 derived).
 It primarily serves two purposes: storage that is common for each instruction
 and a means for generically accessing virtual functions.
 The common information consists of a name - or more specifically the instructio
n mnemonic, the opcode, and a pointer to the processor owning the instruction.
 Some of the virtual functions are 'execute' and 'name'.
 As the hex file is decoded, instances of the instructions are created and
 stored in an array called program_memory.
 The index into this array is the address at which the instruction resides.
 To execute an instruction the following code sequence is invoked:
\layout Quotation

program_memory[pc.value]->execute();
\layout Standard

which says, get the instruction at the current program counter (pc.value)
 and invoke via the virtual function execute().
 This approach allows execution break points to be easily set.
 A special break point instruction can replace the one residing in the program
 memory array.
 When 'execute' is called the break point can be invoked.
\layout Section

General File Registers
\begin_inset LatexCommand \index{registers}

\end_inset 


\layout Standard

A file register is simulated by the 'file_register' class.
 There is one instance of a 'file_register' object for each file register
 in the PIC.
 All of the registers are collected together into an array called 'registers'
 which is indexed by the registers' corresponding PIC addresses.
 The array is linear and not banked like it is in the PIC.
 (Banking is handled during the simulation.)
\layout Section

Special File Registers
\layout Standard

Special file registers are all of the other registers that are not general
 file registers.
 This includes the core registers like status and option and also the peripheral
 registers like eeadr for the eeprom.
 The special file registers are derived from the general file registers
 and are also stored in the 'registers' array.
 There is one instance for each register - even if the register is accessible
 in more than one bank.
 So for example, there's only one instance for the 'status' register, however
 it may be accessed through the 'registers' array in more than one place.
\layout Standard

All file registers are accessed by the virtual functions 'put' and 'get'.
 This is done for two main reasons.
 First, it conveniently encapsulates the breakpoint overhead (for register
 breakpoints) in the file register and not in the instruction.
 Second, and more important, it allows derived classes to implement the
 put and get more specifically.
 For example, a 'put' to the indf register is a whole lot different than
 a put to the intcon register.
 In each case, the 'put' initiates an action beyond simply storing a byte
 of data in an array.
 It also allows the following code sequence to be easily implemented:
\layout LyX-Code

movlw   trisa   ;Get the address of tris 
\layout LyX-Code

movwf   fsr 
\layout LyX-Code

movf    indf,w  ;Read trisa indirectly
\layout Section

Example of an instruction
\layout Standard

Here's an example of the code for the movf instruction that illustrates
 what has been discussed above.
 Somewhere in gpsim the code sequence:
\layout LyX-Code

program_memory[pc.value]->execute();
\layout Standard

is executed.
 Let's say that the pc is pointing to a movf instruction.
 The ->execute() virtual function will invoke MOVF::execute.
 I've added extra comments (that aren't in the main code) to illustrate
 in detail what's happening.
\layout LyX-Code

void MOVF::execute(void)
\layout LyX-Code

{
\layout LyX-Code

  unsigned int source_value;
\layout LyX-Code

 
\layout LyX-Code

  // All instructions are 'traced' (discussed below).
 It's sufficient 
\layout LyX-Code

  //to only store the opcode.
 However, even this may be unnecessary since 
\layout LyX-Code

  //the progam counter is also traced.
 Expect this to disappear in the 
\layout LyX-Code

  //future...
 
\layout LyX-Code

  trace.instruction(opcode);
\layout LyX-Code

 
\layout LyX-Code

  // 'source' is a pointer to a 'file_register' object.
 It is initialized 
\layout LyX-Code

  //by reading the 'registers' array.
 Note that the index depends on the 
\layout LyX-Code

  //'rp' bits (actually just one bit) in the status register.
 Time is
\layout LyX-Code

  // saved by caching rp as opposed to decoding the status register.
\layout LyX-Code

  source = cpu->registers[cpu->rp | opcode&REG_IN_INSTRUCTION_MASK];
\layout LyX-Code

 
\layout LyX-Code

  // We have no idea which register we are trying to access and how it 
\layout LyX-Code

  //should be accessed or if there's a breakpoint set on it.
 No problem,
\layout LyX-Code

  //the virtual function 'get' will resolve all of those details
\layout LyX-Code

  // and 'do the right thing'.
\layout LyX-Code

  source_value = source->get();
\layout LyX-Code

 
\layout LyX-Code

  // If the destination is W, then the constructor has already initialized
 
\layout LyX-Code

  //'destination'.
 Otherwise the destination and source are the same.
\layout LyX-Code

  if(opcode&DESTINATION_MASK)
\layout LyX-Code

    destination = source;      // Result goes to source
\layout LyX-Code

 
\layout LyX-Code

  // Write the source value to the destination.
 Again, we have no idea 
\layout LyX-Code

  // where the destination may be or
\layout LyX-Code

  // or how the data should be written there.
\layout LyX-Code

  destination->put(source_value);
\layout LyX-Code

 
\layout LyX-Code

  // The movf instruction will set Z (zero) bit in the status register
\layout LyX-Code

  //if the source value was zero.
\layout LyX-Code

  cpu->status.put_Z(0==source_value);
\layout LyX-Code

 
\layout LyX-Code

  // Finally, advance the pc by one.
\layout LyX-Code

  cpu->pc.increment();
\layout LyX-Code

 
\layout LyX-Code

}
\layout LyX-Code

 
\layout Section

Trace
\layout Standard

Everything that is simulated is traced - 
\emph on 
all
\emph toggle 
 of the time.
 The trace buffer is one huge circular buffer of integers.
 Information is or'ed with a trace token and then is stored in the trace
 buffer.
 No attempt is made to associate the items in the trace buffer while the
 simulator is simulating a PIC.
 Thus, if you look at the raw buffer you'll see stuff like: cycle counter
 = ..., opcode fetch = ..., register read = ..., register write = ..., etc.
 However, this information is post processed to ascertain what happened
 and when it happened.
 It's also possible to use this information to undo the simulation, or in
 other words you can step backwards.
 I don't have this implemented yet though.
\layout Section

Breakpoints
\layout Standard

Breakpoints fall into three categories: execution, register, and cycle.
\layout Subsubsection

Execution:
\layout Standard

For execution breakpoints a special instruction appropriately called 'Breakpoint
_Instruction' is created and placed into the program memory array at the
 location the break point is desired.
 The original instruction is saved in the newly created breapoint instruction.
 When the break point is cleared, the original instruction is fetched from
 the break point instruction and placed back into the program memory array.
\layout Standard

Note that this scheme has zero overhead.
 The simulation is only affected when the breakpoint is encountered.
\layout Subsubsection

Register:
\layout Standard

There are at least four different breakpoint types that can be set on a
 register: read any value, write any value, read a specific value, or write
 a specific value.
 Like the execution breakpoints, there are special breakpoint registers
 that replace a register object.
 So when the user sets a write breakpoint at register 0x20 for example,
 a new breakpoint object is created and insert into the file register array
 at location 0x20.
 When the simulator attempts to access register location 0x20, the breakpoint
 object will be accessed instead.
\layout Standard

Note that this scheme too has zero overhead, accept when a breakpoint is
 encountered.
\layout Subsubsection

Cycle:
\layout Standard

Cycle breakpoints allow gpsim to alter execution at a specific instruction
 cycle.
 This is useful for running your simulation for a very specific amount of
 time.
 Internally, gpsim makes extensive use of the cycle breakpoints.
 For example, the TMR0 object can be programmed to generate a periodic cycle
 break point.
\layout Standard

Cycle break points are implemented with a sorted doubly-linked list.
 The linked list contains two pieces of information (besides the links):
 the cycle at which the break is to occur and the call back function
\begin_inset Foot
collapsed true

\layout Standard

A call back function is a pointer to a function.
 In this context, gpsim is given a pointer to the function that's to be
 invoked (called) whenever a cycle break occurs.
 
\end_inset 

 that's to be invoked when the cycle does occur.
 The break logic is extremely simple.
 Whenever the cycle counter is advanced (that is, incremented), it's compared
 to the next desired cycle break point.
 If there's NO match, then we're done.
 So the overhead for cycle breaks is the time required to implement a comparison.
 If there IS a match, then the call back function associated with this break
 point is invoked and the next break point in the doubly-linked list serves
 as the reference for the next cycle break.
\layout Chapter*

COPYING
\layout Standard

The document is part of gpsim.
\layout Standard

gpsim is free software; you can redistribute it and/or modify it under the
 terms of the 
\begin_inset LatexCommand \index{GNU}

\end_inset 

GNU General Public 
\begin_inset LatexCommand \index{License}

\end_inset 

License as published by the Free Software Foundation; either version 2,
 or (at your option) any later version.
\layout Standard

gpsim is distributed in the hope that it will be useful, but WITHOUT ANY
 
\begin_inset LatexCommand \index{NO WARRANTY}

\end_inset 

WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.
 See the GNU General Public License for more details.
 
\layout Standard

You should have received a copy of the GNU General Public License along
 with gpsim; see the file COPYING.
 If not, write to the Free Software Foundation, 59 Temple Place - Suite
 330, Boston, MA 02111-1307, USA.
\layout Standard
\start_of_appendix 

\begin_inset LatexCommand \printindex{}

\end_inset 


\the_end
